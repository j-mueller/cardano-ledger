\section{Formal Properties}
\label{sec:properties}

This appendix collects the main formal properties that the new ledger rules are expected to satisfy.

\begin{enumerate}[label=P{\arabic*}:\ ]
\item
  \emph{Consistency with Shelley.}
  \begin{itemize}
    \item properties 15.6 - 15.16 (except 15.8 and 15.13) hold specifically in the $\fun{txValTag}~tx~=~\True$ case, because
    the calculations refer to the UTxO as if it was updated by a scripts-validating transaction
    \item other properties hold as-is
  \end{itemize}

\item
  \emph{Consistency with Multi-Asset.}
  \begin{itemize}
    \item properties 8.1 and 8.2 hold specifically in the $\fun{txValTag}~tx~=~\True$ case, because
    the calculations refer to the UTxO as if it was updated by a scripts-validating transaction
    \item other properties hold as-is
  \end{itemize}
\end{enumerate}


\begin{definition}
  For a state $s$ that is used in any subtransaction of
  $\mathsf{CHAIN}$, we define $\Utxo(s) \in \UTxO$ to be the $\UTxO$
  contained in $s$, or an empty map if it does not exist. This is
  similar to the definition of $\Val$ in the Shelley specification.

  Similarly, we also define $\field_{v}~(s)$ for the field $v$ that is part of
  the ledger state $s$, referenced by the typical variable name (eg. $\var{fees}$
  for the fee pot on the ledger).
\end{definition}

We also define a helper function $\varphi$ as follows:
\[\varphi(x, tx) :=
  \begin{cases}
    x & \fun{txValTag}~tx = \True \\
    0 & \fun{txValTag}~tx = \False
  \end{cases}\]
This function is useful to distinguish between the two
cases where a transaction can mint tokens or not, depending on whether
its scripts validate.

\begin{property}[General Accounting]
  \label{prop:pov}
  The \emph{general accounting} property in Alonzo encompasses two parts
  \begin{itemize}
    \item preservation of value property expressed via the $\fun{produced}$ and $\fun{consumed}$
    calculations, applicable for transactions with $\fun{txValTag}~tx~=~\True$, which
    is specified as in the ShelleMA POV.
    \item the preservation of value for $\fun{txValTag}~tx~=~\False$, when
    only the collateral fees are collected into the fee pot.
  \end{itemize}

Both of these are expressed in the following lemma.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$, if
  \begin{equation*}
    e\vdash s\trans{utxos}{tx}s'
  \end{equation*}
  then
  \begin{equation*}
    \Val(s) + \varphi(\fun{mint}~(\fun{txbody}~tx), tx) = \Val(s')
  \end{equation*}
\end{lemma}

\begin{proof}
  In the case that $\fun{txValTag}~tx = \True$ holds, the proof is
  identical to the proof of Lemma 9.1 of the multi-asset
  specification. Otherwise, the transition must have been done via the
  $\mathsf{Scripts-No}$ rule, which removes
  $\fun{collateral}~(\fun{txbody}~tx)$ from the UTxO, and increases the fee pot by the amount of the sum of Ada in the
  collateral UTxO entries. The value contained in $s$ is not changed.

  Note that in the $\fun{feesOK}$ function, there is a check that verifies
  that, in the case that there are non-native scripts, there are no non-Ada tokens in the UTxOs
  which the collateral inputs reference, so non-Ada tokens do not get minted, burned, or transfered
  in this case.
\end{proof}
\end{property}

\begin{property}[No Changes Except Fees]
  \label{prop:fees-only}
  If a transaction is accepted and marked as paying collateral only
  (i.e. $\fun{txValTag}~tx = \False$), then the only change to the ledger
  when processing the transaction is that the collateral inputs
  are moved to the fee pot.

  \begin{lemma}
    For all environments $e$, transactions $tx$ and states $s, s'$, if $\fun{txvaltag}~tx = \False$ and
    \begin{equation*}
      e\vdash s\trans{ledger}{tx}s'
    \end{equation*}
    then
    \begin{itemize}
      \item $\Utxo(s') = \fun{collateral}~{tx} \subtractdom \Utxo(s)$
      \item $\field_{fees}~(s') = \field~\var{fees}~(s) + \fun{coin}~(\Val~(\fun{collateral}~{tx} \subtractdom \Utxo(s)))$
      \item $\field_{v}~(s') = \field_{v}~(s)$ for all $v~\neq~{fees}, ~v~\neq~{utxo}$
    \end{itemize}
  \end{lemma}

  \begin{proof}
  The top-level single-transaction processing transition is $\mathsf{LEDGER}$.
   In the case that $\fun{txValTag}~tx = \False$, this transition calls the rule
   that does not update $\DPState$ at all, only the $\UTxOState$. This state update is specified
   in the $\mathsf{UTXOS}$ transition (and applied via the $\mathsf{UTXO}$ and $\mathsf{UTXOW}$ transitions).

   The only parts of the state that are updated are the UTxO, where the collateral entries
   are removed, and the fee pot, which is increased by the amount of the sum of Ada in the
   collateral UTxO entries.
  \end{proof}
\end {property}

\begin{property}[Validating when No NN Scripts]
  \label{prop:is-valid}

Whenever a valid transaction does not have any non-native scripts, its
$\fun{txValTag} = \True$.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s',
  \end{equation*}
  If $\range (\fun{txscripts}~tx) \cap \ScriptNonNative = \emptyset$
  then $\fun{txValTag} = \True$.
\end{lemma}
\begin{proof}
  With the same argument as previously, we only need to discuss the
  equivalent claim for the $\mathsf{UTXOS}$ transition. Under these
  assumptions, $\var{sLst} := \fun{collectTwoPhaseScriptInputs}$ is an empty
  list. Thus $\fun{evalScripts}~sLst = \True$, and the transition rule
  had to be $\mathsf{Scripts{-}Yes}$.
\end{proof}
\end{property}

\begin{property}[Paying fees]
  \label{prop:pay-fees}

A transaction always pays into the fee pot.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s',
  \end{equation*}
  The following holds : $\field_{fees}~(s)~<~\field_{fees}~(s')$.
\end{lemma}
\begin{proof}
  The fee pot is updated by the $\mathsf{Scripts{-}Yes}$ and the $\mathsf{Scripts{-}No}$
  rules, one of which is necessarily called by a valid transaction.
\end{proof}
\end{property}

\begin{property}[Replay protection]
  \label{prop:replay}

A transaction always removes at least one UTxO entry from the ledger, which provides
replay protection.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s',
  \end{equation*}
  The following holds : $\Utxo~(s)~\nsubseteq~\Utxo~(s')$.
\end{lemma}
\begin{proof}
  The UTxO is updated by the $\mathsf{Scripts{-}Yes}$ and the $\mathsf{Scripts{-}No}$
  rules, on of which is necessarily called by a valid transaction. Both of these
  rules remove UTxOs corresponding to a set of inputs.

  In both cases, there is a check that the removed inputs set is non-empty.
  The $\mathsf{Scripts{-}Yes}$ rule of the $\mathsf{UTXOS}$ transition
  removes the UTxOs associated with the input set $\fun{txinputs}~{tx}$ from the ledger.
  The $\fun{txinputs}~{tx}$ set must be non-empty because there is a check in the
  $\mathsf{UTXO}$ rule (which calls $\mathsf{UTXOS}$) that ensure this is true.

  For the $\mathsf{Scripts{-}No}$ rule of the $\mathsf{UTXOS}$ transition
  removes the UTxOs associated with the input set $\fun{collateral}~{tx}$ from the ledger.
  The $\fun{collateral}~{tx}$ set must be non-empty because
  the $\fun{feesOK}$ function (called by the same rule that calls $\mathsf{UTXO},
  \mathsf{UTXOS}$) ensures that in the case that the $tx$ contains non-native scripts,
  $\fun{collateral}~{tx}$ must be non-empty.

  Note that by property~\ref{prop:is-valid}, non-native scripts must always be present
  if $\fun{txValTag}~tx = \False$ (that is, whenever $\mathsf{Scripts{-}No}$ rule is used).
\end{proof}
\end{property}

\begin{property}[UTxO-changing transitions]
  \label{prop:utxo-change}

Only the $\mathsf{UTXOS}$ transition affects the ledger UTxO in Alonzo.

\begin{lemma}
  For all environments $e$, transitions $\mathsf{TRNS}$, signals $f$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{trns}{f}s',
  \end{equation*}
  The following holds :
  \begin{equation*}
    \Utxo(s) \neq \Utxo (s')~ \Rightarrow~\mathsf{TRNS}~=~\mathsf{UTXOS}
  \end{equation*}
\end{lemma}
\begin{proof}
  By inspecting each transition in this specification, as well as those inherited from the
  Shelley one, we see that any update from the UTxO of $s$ to that of $s'$
  must be done by $\mathsf{UTXOS}$.
\end{proof}
\end{property}

\begin{property}[Script interpreter arguments are fixed (deterministic script evaluation)]
  \label{prop:fixed-inputs}

For this property to hold, we make an important assumption about the Plutus script
interpreter : it is a pure function that receives only the arguments provided by the ledger when it is
invoked by calling the $\fun{runPLCScript}$ function. In particular, it does not
obtain any system randomness, etc. In addition, we assume that the consensus
function $\fun{epochInfoSlotToUTCTime}$ for converting a slot interval into a
system time interval is deterministic. Furthermore, we assume that the two global
constants, $\EpochInfo$ and $\SystemStart$, which it also takes as parameters,
cannot change within the span of an interval on which $\fun{epochInfoSlotToUTCTime}$
succeeds in doing the conversion.

With this in mind, we can make the claim that
all the data that a non-native script interpreter gets as input
is fixed either by

\begin{itemize}
  \item the input itself (or its hash) being inside the transaction body --- and therefore signed, or
  \item fixed by it (or its hash) having been recorded on the ledger
\end{itemize}

The fixed argument values provided by the ledger, together with the assumption that there
are no additional data the interpreter can inspect, allows us to say that
script evaluation is entirely deterministic. More precisely, we say that

\begin{lemma}
  For all environments $e, e'$, transactions $tx, tx'$ and states $s, s', u, u'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s', \\
    e'\vdash u\trans{ledger}{tx'}u', \\
    \txbody{tx} = \txbody{tx'}, \\
    (\fun{languages}~(\fun{txwits}~{tx}))~\restrictdom~\fun{costmdls}~(\field_{pp}(s))~=~(\fun{languages}~(\fun{txwits}~{tx'}))~\restrictdom\fun{costmdls}~(\field_{pp}(s')), \\
  \end{equation*}
  The following holds :

  \[\fun{evalScripts}~{tx}~ \fun{collectTwoPhaseScriptInputs} ~\field_{pp}(s)~\var{tx}~ \Utxo(s)\]
  \[ \Leftrightarrow\]
  \[\fun{evalScripts}~{tx'}~ \fun{collectTwoPhaseScriptInputs} ~\field_{pp}(u)~\var{tx'}~ \Utxo(u)\]

\end{lemma}
\begin{proof}
  Let us consider the use of arguments of $\fun{evalScripts}$ (see Figure \ref{fig:functions:script2}).
  \begin{itemize}
    \item $\var{tx}, \var{tx'}$ : this argument is only inspected in the case that the script $sc$ (the first element
    in the pair at the head of the list
    $((\var{sc}, \var{d}, \var{eu}, \var{cm});\Gamma)$) is a native script. Since all native scripts
    are checked in phase one of validation (see \ref{fig:rules:utxow-alonzo}) by calling $\fun{validateScript}$
    on all scripts attached to the transaction. For this to apply to $sc$, we must also show
    that $sc$ is a script attached to the transaction (see the second argument explanation).
    Note also that the $tx$ argument passed to $\fun{evalScripts}$ at the use site (in the UTXOS transition)
    is the same, unmodified $tx$ as is the signal for the LEDGER transition. We verify this by inspecting
    the sequence of transitions through which it is propagated (UTXOS, UTXO, UTXOW, and LEDGER), and their signals.

    This allows us to conclude that the first argument to $\fun{evalScripts}$
    \begin{itemize}
      \item has no impact on the outcome of the evaluation of the non-native scripts
      as part of running $\fun{evalScripts}$, and
      \item the outcome of native script evaluation by $\fun{evalScripts}$ is the
      same as the outcome of evaluating them in phase-1, since
      it calls the same evaluation function on the same arguments in both cases
      \[\fun{evalTimelock}~\var{tx}~\var{sc}\]
      Note here that we are considering only phase-1 valid transactios here (as we started
      with the assumptions of having valid ledger transitions), therefore
      phase-1 evaluation of native scripts necessarily succeeded for both $tx$ and $tx'$
      in order to proceed to phase-2, wherein $\fun{evalScripts}$ is run
    \end{itemize}

    \item The second argument is a list. We will show that it must be the same list for the $e, s, tx, s'$
    transition case, as it is for $e', u, tx', u'$. The list is constructed by the
    function $\fun{collectTwoPhaseScriptInputs}$ (see \ref{fig:functions:script2}).
    The order of the list does not affect the validation outcome, since the interpreter is run
    on each tuple of a script and its arguments independently of all other tuples in the list.
    The function $\fun{evalTimelock}$ is a $\wedge$-fold over the list. Thus, we ignore the order
    of the elements in the generated list.

    \textbf{Scripts and script purposes : } The $\fun{collectTwoPhaseScriptInputs}$
    function makes a list that contains all pairs of a Plutus script
    with the argumets passed to the interpreter for its evaluation.
    Each script in the list corresponds to a hash returned by
    the $\fun{scriptsNeeded}$ function, which returns the collection of
    all hashes of the scripts (together with their script purposes) needed for validating the UTxOs being spent,
    the policies of the tokens being minted, rewards being withdrawn, and the certificates
    in the transaction.

    The policy IDs, the reward accounts, and certificate credentials kinds of script purposes all include
    the hash of the validating script. All this data is fixed by the transaction body,
    and therefore must be the same for $tx$ and $tx'$. The script purpose and hash pairs are
    included in the collection output by $\fun{scriptsNeeded}$.

    Input-type script purposes are also fixed by the input field of the transaction body.
    To obtain the script hash associated with the input, however,
    the $\fun{scriptsNeeded}$ function also takes the ledger UTxO as a parameter.
    The UTxO is used to make the transaction's inputs into realized inputs.
    A transaction input (if valid) uniquely determines the realized input across the whole
    history of the UTxO, so two phase-1 valid transactions with the same inputs
    will have the same realized inputs even if they are being applied to UTxO states.
    So, like other script purposes (policy IDs, etc.), the script purposes corresponding to
    transaction inputs are always paired with a script hash fixed by the transaction body.

    The UTXOW rule checks that the script hashes collected by $\fun{scriptsNeeded}$
    are exactly the hashes of the scripts attached to the transaction. Therefore, the
    attached scripts of $tx$ and $tx'$ are the same, ie.

    \[ \fun{scriptsNeeded}~\Utxo(s)~tx = \fun{scriptsNeeded}~\Utxo(u)~tx' \]

    \textbf{Interpreter (and script) arguemnts : } The arguments passed to the interpreter
    that are collected
    by $\fun{collectTwoPhaseScriptInputs}$ must also be the same for each
    of the script-hash and puropse pairs returned by $\fun{scriptsNeeded}$.
    In the case of native scripts, the arguments are never inspected at all.
    The list of arguments for a given non-native scripts is made up of the following
    terms. These terms are
    always listed in the same order --- datum (if the script purpose is an input), redeemer, context, execution units,
    cost model.

    \begin{itemize}
      \item Datums : a datum is the first element of the input list whenever
      the function $\fun{getDatum}$ (Figure \ref{fig:functions:script2})
      finds one attached to the transaction. In the case the script purpose
      is of the input type, the datum it returns is one that
      is associated with the corresponding realized input. More precisely, it is the datum whose
      hash is specified in the realized input, and is looked up by hash in the $\fun{txdats}$
      transaction field. If there is no datum hash in the realized input, or the script purpose
      is of a non-input type, no datum is added to the input list of the script.

      The UTXOW rule checks that the transaction is carrying all datums corresponding
      to its realized inputs. Thus, we can say that for both $tx$ and $tx'$, the
      $\fun{getDatum}$ function returns the same datums for each hash-purpose
      pair returned by $\fun{scriptsNeeded}$ (recall that this set of pairs
      are the same for both transactions).

      \item Redeemers, execution units, and the cost model : these inputs are are fixed by the body of the transaction
      by the precondition in the UTXOW rule
      which checks contents of the $\fun{wppHash}$ field in the body a transaction against the calculated hash
      of the tuple of the script data structure attached to the transaction, the cost models for the
      languages of the transaction's scripts, and the attached datum objects. Since the bodies of
      the two transactions are the same, the fields hashed by $\fun{hashWitnessPPData}$ must also be the same.

      \item Context : For each for the pairs returned by $\fun{scriptsNeeded}$,
      the context, built by $\fun{valContext}$, is made up of the constructed $\TxInfo$ (which is unique for
      a given transaction), and the script purpose from the script hash and purpose pair.
      We now demonstrate that each field of the $\TxInfo$ structure must be
      the same for two transactions with the same body, so

      \[ \fun{txInfo}~\wcard~\Utxo(s)~\var{tx} = \fun{txInfo}~\wcard~\Utxo(u)~\var{tx'}\]

      We omitted the first argument, which is a script language, because in this proof, we only consider
      a single non-native script language, $\PlutusVI$. All fields of the $\TxInfo$
      structure, with the exceptions listed below,
      are obtained directly from the transaction body (see \ref{sec:txinfo}),
      and therefore must be the same in $tx$ and $tx'$. The fields not directly
      appearing in the body are :

      \begin{itemize}
        \item $\fun{txInfoInputs}$ : this field contains the realized inputs of
        the transaction which are fixed by the transaction and the unique
        UTxO entries to which the inputs correspond

        \item $\fun{txInfoValidRange}$ : this field contains the transaction
        validity interval as system time (converted from the slot numbers, which are
        used to speficy the interval in the transaction body). This conversion is
        done by a function defined in the consensus layer, and takes two global
        constants in addition to the slot interval itself. Since the slot interval
        conversion function $\fun{epochInfoSlotToUTCTime}$ necessarily
        succeeds if both $tx$ and $tx'$ pass phase-1 validation, the additional
        global constant arguments must be the same (by assumption). The determinism of this conversion
        is one of the assumptions of this property.

        \item $\fun{txInfoData}$ : this field is populated with the datums (and their
        hashes) in the transaction field $\fun{txdats}$, which is fixed by the body
        via the $\fun{wppHash}$ field

        \item $\fun{txInfoId}$ : this field contains the hash of the transaction body,
        which is clearly the same for transactions with the same body
      \end{itemize}
    \end{itemize}

  \end{itemize}
\end{proof}
\end{property}

\begin{enumerate}
\item
  \emph{Extended UTxO Validation.}
  If a transaction extends the UTxO, all its scripts validate, and
  if it has a script that does not validate, it cannot extend the
  UTxO.
\item
  \emph{Cost Increase.} if a transaction is valid, it will remain valid if you increase the execution units
\item
  \emph{Cost Lower Bound.} if a transaction contains at least one valid script, it must have at least one execution unit
\item
  \emph{Tx backwards Compatibility.} Any transaction that was accepted in a previous version of the ledger rules
    has exactly the same cost and effect, except that the transaction output is extended.
\item \emph{Run all scripts.} All scripts attached to a transaction are run
\item \emph{Scripts are run on correct inputs.}
  A script is run for everything witnessed with a non-native script, and the script will
get all the correct inputs, which must be present.
\item
  ... \todo{Anything else?}
\end{enumerate}
