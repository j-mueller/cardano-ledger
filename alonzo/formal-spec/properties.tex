\section{Formal Properties}
\label{sec:properties}

This appendix collects the main formal properties that the new ledger rules are expected to satisfy.

\begin{enumerate}[label=P{\arabic*}:\ ]
\item
  \emph{Consistency with Shelley.}
  \begin{itemize}
    \item properties 15.6 - 15.16 (except 15.8 and 15.13) hold specifically in the $\fun{txValTag}~tx~=~\True$ case, because
    the calculations refer to the UTxO as if it was updated by a scripts-validating transaction
    \item other properties hold as-is
  \end{itemize}

\item
  \emph{Consistency with Multi-Asset.}
  \begin{itemize}
    \item properties 8.1 and 8.2 hold specifically in the $\fun{txValTag}~tx~=~\True$ case, because
    the calculations refer to the UTxO as if it was updated by a scripts-validating transaction
    \item other properties hold as-is
  \end{itemize}
\end{enumerate}


\begin{definition}
  For a state $s$ that is used in any subtransaction of
  $\mathsf{CHAIN}$, we define $\Utxo(s) \in \UTxO$ to be the $\UTxO$
  contained in $s$, or an empty map if it does not exist. This is
  similar to the definition of $\Val$ in the Shelley specification.

  Similarly, we also define $\field_{v}~(s)$ for the field $v$ that is part of
  the ledger state $s$, referenced by the typical variable name (eg. $\var{fees}$
  for the fee pot on the ledger).
\end{definition}

We also define a helper function $\varphi$ as follows:
\[\varphi(x, tx) :=
  \begin{cases}
    x & \fun{txValTag}~tx = \True \\
    0 & \fun{txValTag}~tx = \False
  \end{cases}\]
This function is useful to distinguish between the two
cases where a transaction can mint tokens or not, depending on whether
its scripts validate.

\begin{property}[General Accounting]
  \label{prop:pov}
  The \emph{general accounting} property in Alonzo encompasses two parts
  \begin{itemize}
    \item preservation of value property expressed via the $\fun{produced}$ and $\fun{consumed}$
    calculations, applicable for transactions with $\fun{txValTag}~tx~=~\True$, which
    is specified as in the ShelleMA POV.
    \item the preservation of value for $\fun{txValTag}~tx~=~\False$, when
    only the collateral fees are collected into the fee pot.
  \end{itemize}

Both of these are expressed in the following lemma.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$, if
  \begin{equation*}
    e\vdash s\trans{utxos}{tx}s'
  \end{equation*}
  then
  \begin{equation*}
    \Val(s) + \varphi(\fun{mint}~(\fun{txbody}~tx), tx) = \Val(s')
  \end{equation*}
\end{lemma}

\begin{proof}
  In the case that $\fun{txValTag}~tx = \True$ holds, the proof is
  identical to the proof of Lemma 9.1 of the multi-asset
  specification. Otherwise, the transition must have been done via the
  $\mathsf{Scripts-No}$ rule, which removes
  $\fun{collateral}~(\fun{txbody}~tx)$ from the UTxO, and increases the fee pot by the amount of the sum of Ada in the
  collateral UTxO entries. The value contained in $s$ is not changed.

  Note that in the $\fun{feesOK}$ function, there is a check that verifies
  that, in the case that there are non-native scripts, there are no non-Ada tokens in the UTxOs
  which the collateral inputs reference, so non-Ada tokens do not get minted, burned, or transfered
  in this case.
\end{proof}
\end{property}

\begin{property}[No Changes Except Fees]
  \label{prop:fees-only}
  If a transaction is accepted and marked as paying collateral only
  (i.e. $\fun{txValTag}~tx = \False$), then the only change to the ledger
  when processing the transaction is that the collateral inputs
  are moved to the fee pot.

  \begin{lemma}
    For all environments $e$, transactions $tx$ and states $s, s'$, if $\fun{txvaltag}~tx = \False$ and
    \begin{equation*}
      e\vdash s\trans{ledger}{tx}s'
    \end{equation*}
    then
    \begin{itemize}
      \item $\Utxo(s') = \fun{collateral}~{tx} \subtractdom \Utxo(s)$
      \item $\field_{fees}~(s') = \field~\var{fees}~(s) + \fun{coin}~(\Val~(\fun{collateral}~{tx} \subtractdom \Utxo(s)))$
      \item $\field_{v}~(s') = \field_{v}~(s)$ for all $v~\neq~{fees}, ~v~\neq~{utxo}$
    \end{itemize}
  \end{lemma}

  \begin{proof}
  The top-level single-transaction processing transition is $\mathsf{LEDGER}$.
   In the case that $\fun{txValTag}~tx = \False$, this transition calls the rule
   that does not update $\DPState$ at all, only the $\UTxOState$. This state update is specified
   in the $\mathsf{UTXOS}$ transition (and applied via the $\mathsf{UTXO}$ and $\mathsf{UTXOW}$ transitions).

   The only parts of the state that are updated are the UTxO, where the collateral entries
   are removed, and the fee pot, which is increased by the amount of the sum of Ada in the
   collateral UTxO entries.
  \end{proof}
\end {property}

\begin{property}[Validating when No NN Scripts]
  \label{prop:is-valid}

Whenever a valid transaction does not have any non-native scripts, its
$\fun{txValTag} = \True$.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s',
  \end{equation*}
  If $\range (\fun{txscripts}~tx) \cap \ScriptNonNative = \emptyset$
  then $\fun{txValTag} = \True$.
\end{lemma}
\begin{proof}
  With the same argument as previously, we only need to discuss the
  equivalent claim for the $\mathsf{UTXOS}$ transition. Under these
  assumptions, $\var{sLst} := \fun{collectTwoPhaseScriptInputs}$ is an empty
  list. Thus $\fun{evalScripts}~sLst = \True$, and the transition rule
  had to be $\mathsf{Scripts{-}Yes}$.
\end{proof}
\end{property}

\begin{property}[Paying fees]
  \label{prop:pay-fees}

A transaction always pays into the fee pot.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s',
  \end{equation*}
  The following holds : $\field_{fees}~(s)~<~\field_{fees}~(s')$.
\end{lemma}
\begin{proof}
  The fee pot is updated by the $\mathsf{Scripts{-}Yes}$ and the $\mathsf{Scripts{-}No}$
  rules, one of which is necessarily called by a valid transaction.
\end{proof}
\end{property}

\begin{property}[Replay protection]
  \label{prop:replay}

A transaction always removes at least one UTxO entry from the ledger, which provides
replay protection.

\begin{lemma}
  For all environments $e$, transactions $tx$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s',
  \end{equation*}
  The following holds : $\Utxo~(s)~\nsubseteq~\Utxo~(s')$.
\end{lemma}
\begin{proof}
  The UTxO is updated by the $\mathsf{Scripts{-}Yes}$ and the $\mathsf{Scripts{-}No}$
  rules, on of which is necessarily called by a valid transaction. Both of these
  rules remove UTxOs corresponding to a set of inputs.

  In both cases, there is a check that the removed inputs set is non-empty.
  The $\mathsf{Scripts{-}Yes}$ rule of the $\mathsf{UTXOS}$ transition
  removes the UTxOs associated with the input set $\fun{txinputs}~{tx}$ from the ledger.
  The $\fun{txinputs}~{tx}$ set must be non-empty because there is a check in the
  $\mathsf{UTXO}$ rule (which calls $\mathsf{UTXOS}$) that ensure this is true.

  For the $\mathsf{Scripts{-}No}$ rule of the $\mathsf{UTXOS}$ transition
  removes the UTxOs associated with the input set $\fun{collateral}~{tx}$ from the ledger.
  The $\fun{collateral}~{tx}$ set must be non-empty because
  the $\fun{feesOK}$ function (called by the same rule that calls $\mathsf{UTXO},
  \mathsf{UTXOS}$) ensures that in the case that the $tx$ contains non-native scripts,
  $\fun{collateral}~{tx}$ must be non-empty.

  Note that by property~\ref{prop:is-valid}, non-native scripts must always be present
  if $\fun{txValTag}~tx = \False$ (that is, whenever $\mathsf{Scripts{-}No}$ rule is used).
\end{proof}
\end{property}

\begin{property}[UTxO-changing transitions]
  \label{prop:utxo-change}

Only the $\mathsf{UTXOS}$ transition affects the ledger UTxO in Alonzo.

\begin{lemma}
  For all environments $e$, transitions $\mathsf{TRNS}$, signals $f$ and states $s, s'$ such that
  \begin{equation*}
    e\vdash s\trans{trns}{f}s',
  \end{equation*}
  The following holds :
  \begin{equation*}
    \Utxo(s) \neq \Utxo (s')~ \Rightarrow~\mathsf{TRNS}~=~\mathsf{UTXOS}
  \end{equation*}
\end{lemma}
\begin{proof}
  By inspecting each transition in this specification, as well as those inherited from the
  Shelley one, we see that any update from the UTxO of $s$ to that of $s'$
  must be done by $\mathsf{UTXOS}$.
\end{proof}
\end{property}

\begin{property}[Script interpreter inputs are fixed]
  \label{prop:fixed-inputs}

For this property to hold, we make an important assumption about the Plutus script
interpreter : it is a pure function that receives only the inputs provided by the ledger when it is
invoked by calling the $\fun{runPLCScript}$ function. In particular, it does not
obtain any system randomness, etc. With this in mind, we can make the claim that
all the data that a non-native script interpreter gets as input
is fixed either by

\begin{itemize}
  \item the input itself (or its hash) being inside the transaction body --- and therefore signed, or
  \item fixed by it (or its hash) having been recorded on the ledger
\end{itemize}

\begin{lemma}
  For all environments $e, e'$, transactions $tx, tx'$ and states $s, s', u, u'$ such that
  \begin{equation*}
    e\vdash s\trans{ledger}{tx}s', \\
    e'\vdash u\trans{ledger}{tx'}u', \\
    \txbody{tx} = \txbody{tx'}, \\
    (\fun{languages}~(\fun{txwits}~{tx}))~\restrictdom~\fun{costmdls}~(\field_{pp}(s))~=~(\fun{languages}~(\fun{txwits}~{tx'}))~\restrictdom\fun{costmdls}~(\field_{pp}(s')), \\
  \end{equation*}
  The following holds :

  \[\fun{evalScripts}~{tx}~ \fun{collectTwoPhaseScriptInputs} ~\field_{pp}(s)~\var{tx}~ \Utxo(s)\]
  \[ \Leftrightarrow\]
  \[\fun{evalScripts}~{tx'}~ \fun{collectTwoPhaseScriptInputs} ~\field_{pp}(u)~\var{tx'}~ \Utxo(u)\]

\end{lemma}
\begin{proof}
  Let us consider the use of arguments of $\fun{evalScripts}$ (see Figure \ref{fig:functions:script2}).
  \begin{itemize}
    \item $\var{tx}, \var{tx'}$ : this argument is only inspected in the case that the script $sc$ (the first element
    in the pair at the head of the list
    $((\var{sc}, \var{d}, \var{eu}, \var{cm});\Gamma)$) is a native script. Since all native scripts
    are checked in phase one of validation (see \ref{fig:rules:utxow-alonzo}) by calling $\fun{validateScript}$
    on all scripts attached to the transaction. For this to apply to $sc$, we must also show
    that $sc$ is a script attached to the transaction (see the second argument explanation).
    Note also that the $tx$ argument passed to $\fun{evalScripts}$ at the use site (in the UTXOS transition)
    is the same, unmodified $tx$ as is the signal for the LEDGER transition. We verify this by inspecting
    the sequence of transitions through which it is propagated (UTXOS, UTXO, UTXOW, and LEDGER), and their signals.

    This allows us to conclude that the first argument to $\fun{evalScripts}$
    \begin{itemize}
      \item has no impact on the outcome of the evaluation of the non-native scripts
      as part of running $\fun{evalScripts}$, and
      \item the outcome of native script evaluation by $\fun{evalScripts}$ is the
      same as the outcome of evaluating them in phase-1, since
      it calls the same evaluation function on the same inputs in both cases
      \[\fun{evalTimelock}~\var{tx}~\var{sc}\]
      Note here that we are considering only phase-1 valid transactios here (as we started
      with the assumptions of having valid ledger transitions), therefore
      phase-1 evaluation of native scripts necessarily succeeded for both $tx$ and $tx'$
      in order to proceed to phase-2, wherein $\fun{evalScripts}$ is run
    \end{itemize}

    \item The second argument is a list. We will show that it must be the same list for the $e, s, tx, s'$
    transition case, as it is for $e', u, tx', u'$. The list is constructed by the
    function $\fun{collectTwoPhaseScriptInputs}$ (see \ref{fig:functions:script2}).
    The order of the list does not affect the validation outcome, since the interpreter is run
    on each pair of a script and its inputs independently of all other pairs in the list.
    The function $\fun{evalTimelock}$ is a $\wedge$-fold over the list. Thus, we ignore the order
    of the elements in the generated list.

    \textbf{Scripts and script purposes : } The $\fun{collectTwoPhaseScriptInputs}$
    function makes a list of out the set of all pairs that associate a Plutus script
    with its inputs. Each script in the list corresponds to one returned by
    the $\fun{scriptsNeeded}$ function, which returns the collection of
    all scripts (together with their script purposes) needed for validating the UTxOs being spent,
    the policies of the tokens being minted, rewards being withdrawn, and the certificates
    in the transaction.

    The policy IDs, the reward accounts, and certificate credentials kinds of script purposes all include
    the hash of the validating script. All this data is fixed by the transaction body,
    and therefore must be the same for $tx$ and $tx'$. The script purpose and hash pairs are
    included in the collection output by $\fun{scriptsNeeded}$.

    Input-type script purposes are also fixed by the input field of the transaction body.
    To obtain the script hash associated with the input, however,
    the $\fun{scriptsNeeded}$ function also takes the ledger UTxO as a parameter.
    The UTxO is used to make the transaction's inputs into realized inputs.
    A transaction input (if valid) uniquely determines the realized input across the whole
    history of the UTxO, so two phase-1 valid transactions with the same inputs
    will have the same realized inputs even if they are being applied to UTxO states.
    So, like other script purposes (policy IDs, etc.), the script purposes corresponding to
    transaction inputs are always paired with a script hash fixed by the transaction body.

    \textbf{Scripts inputs : } The inputs to the scripts that are collected
    by $\fun{collectTwoPhaseScriptInputs}$ must also be the same for each script in both cases.
    In the case of native scripts, the inputs are never inspected at all.
    The list of inputs for each non-native scripts is made up of the following
    (always in the same order):

    \begin{itemize}
      \item Datums : a datum is the first element of the input list whenever
      the function $\fun{getDatum}$ (Figure \ref{fig:functions:script2})
      finds one attached to the transaction. The datum it returns is one that
      is associated with the $\ScriptPurpose$ of the script for which
      this list of inputs is being compiled. 
      \item Redeemers :
      transaction
      \item Context :
      \item Execution units :
      \item Cost model :
    \end{itemize}


    We can tell by inspecting this function that it does not
    inspect all protocol parameters, but only the cost models. The cost models for
    since the check (in UTXOW)

    \[\fun{wppHash}~{txb}~=~\fun{hashWitnessPPData}~\var{pp}~(\fun{languages}~{txw})~(\fun{txrdmrs}~{txw})~(\fun{txdats}~{txw})\]

    ensures that the hash of the cost models of the script languages in the transaction, together
    with the attached redeemers, is the same


    $((\var{sc}, \var{d}, \var{eu}, \var{cm});\Gamma)$
  \end{itemize}
\end{proof}
\end{property}

\begin{enumerate}
\item
  \emph{Extended UTxO Validation.}
  If a transaction extends the UTxO, all its scripts validate, and
  if it has a script that does not validate, it cannot extend the
  UTxO.
\item
  \emph{Cost Increase.} if a transaction is valid, it will remain valid if you increase the execution units
\item
  \emph{Cost Lower Bound.} if a transaction contains at least one valid script, it must have at least one execution unit
\item
  \emph{Tx backwards Compatibility.} Any transaction that was accepted in a previous version of the ledger rules
    has exactly the same cost and effect, except that the transaction output is extended.
\item \emph{Run all scripts.} All scripts attached to a transaction are run
\item \emph{Scripts are run on correct inputs.}
  A script is run for everything witnessed with a non-native script, and the script will
get all the correct inputs, which must be present.
\item \emph{Determinism of script validation.} In an otherwise valid transaction which remains valid
  despite ledger state changes, the outcome
  of script validation is not affected by these ledger state changes.
\item
  ... \todo{Anything else?}
\end{enumerate}
